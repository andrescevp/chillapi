<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>chillapi.endpoints.tables API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>chillapi.endpoints.tables</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import List

import inflect
import psycopg2
import simplejson
import sqlalchemy
from flask import request
from jsonschema.exceptions import ValidationError as JsonSchemaValidationError
from openapi_schema_validator import validate as json_swagger_schema_validator
from simplejson.errors import JSONDecodeError
from wtforms.validators import ValidationError

from chillapi.abc import Repository
from chillapi.app.flask_restful_swagger_3 import swagger
from chillapi.app.forms import create_form_class, generate_form_swagger_schema_from_form
from chillapi.database import DB_DIALECT_POSTGRES
from chillapi.database.query_builder import (
    create_select_filtered_paginated_ordered_query,
    create_select_filtered_paginated_query_count,
)
from chillapi.database.repository import _MAGIC_QUERIES
from chillapi.exceptions.api_manager import ConfigError
from chillapi.exceptions.http import NotFoundException, RequestInvalidFieldSchemaError, RequestSchemaError
from chillapi.extensions.audit import AuditLog
from chillapi.logger.app_loggers import logger
from chillapi.swagger.http import AutomaticResource, ResourceResponse
from chillapi.swagger.schemas import (
    create_swagger_type_from_dict,
    get_delete_list_endpoint_schema,
    get_delete_single_endpoint_schema,
    get_get_list_endpoint_schema,
    get_get_single_endpoint_schema,
    get_post_list_endpoint_schema,
    get_post_single_endpoint_schema,
    get_put_list_endpoint_schema,
    get_put_single_endpoint_schema,
)
from chillapi.swagger.utils import (
    get_error_swagger_schema,
    get_filter_schema,
    get_list_filtered_request_swagger_schema,
    get_list_filtered_response_swagger_schema,
    get_not_found_swagger_schema,
    get_order_schema,
    get_response_swagger_schema,
    get_revisable_response_swagger_schema,
    get_size_schema,
    python_to_swagger_types,
)

revisable_response = get_revisable_response_swagger_schema()
error_response = get_error_swagger_schema()
not_found = get_not_found_swagger_schema()

inflector = inflect.engine()


def _get_extension_default_field(table_extensions, extension):
    &#34;&#34;&#34;

    :param table_extensions:
    :param extension:

    &#34;&#34;&#34;
    _registered = extension in table_extensions.keys()
    _enable = False
    default_field = None
    if &#34;enable&#34; in table_extensions[extension]:
        _enable = table_extensions[extension][&#34;enable&#34;]
    if _registered and _enable:
        default_field = table_extensions[extension][&#34;default_field&#34;]
    if _enable and default_field is None:
        raise ConfigError(f&#34;{extension} is enabled but there is not default_field&#34;)

    return _enable, default_field


def _get_form(class_name: str, columns_map: dict, method: str, extensions: dict, as_array=False):
    &#34;&#34;&#34;

    :param class_name: str:
    :param columns_map: dict:
    :param method: str:
    :param extensions: dict:
    :param as_array:  (Default value = False)

    &#34;&#34;&#34;
    form_class = create_form_class(class_name, method, columns_map, extensions)
    form_schema_json = generate_form_swagger_schema_from_form(method, form_class, as_array=as_array)

    return form_class, form_schema_json


def _column_type_to_swagger_type_url(type):
    &#34;&#34;&#34;

    :param type:

    &#34;&#34;&#34;
    id_field_where_type = f&#34;{type.python_type.__name__}:&#34;
    if id_field_where_type != &#34;int:&#34;:
        id_field_where_type = &#34;&#34;
    return id_field_where_type


def create_get_single_endpoint_class(table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: Repository):
    &#34;&#34;&#34;

    :param table: dict:
    :param allowed_columns: List:
    :param allowed_columns_map: dict:
    :param extensions: dict:
    :param repository: Repository:

    &#34;&#34;&#34;
    table_slug = table[&#34;slug&#34;]
    table_name = table[&#34;name&#34;]
    model_name = table[&#34;model_name&#34;]
    id_field = table[&#34;id_field&#34;]

    id_field_where_type = _column_type_to_swagger_type_url(table[&#34;columns&#34;][id_field][&#34;type&#34;])
    response_schema = get_response_swagger_schema(allowed_columns_map, f&#34;{model_name}GetSingleEndpoint&#34;)
    soft_delete_extension = extensions[&#34;soft_delete&#34;]
    swagger_docs = get_get_single_endpoint_schema(model_name, id_field_where_type, response_schema)

    class GetSingleEndpoint(AutomaticResource):
        &#34;&#34;&#34; &#34;&#34;&#34;

        route = f&#34;/read/{table_slug}/&lt;{id_field_where_type}id&gt;&#34;
        endpoint = f&#34;{model_name}GetSingleEndpoint&#34;
        representations = swagger_docs
        db_table = table

        def request(self, **args) -&gt; ResourceResponse:
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            id = args[&#34;id&#34;]
            try:
                response = ResourceResponse()

                query = {id_field: {&#34;op&#34;: &#34;=&#34;, &#34;value&#34;: id}}
                query_values = {id_field: id}

                if soft_delete_extension.enabled:
                    query, query_values, soft_delete_extension.add_query_filter(query, query_values)

                record = repository.fetch_by(
                    table_name,
                    allowed_columns,
                    query,
                    query_values,
                )

                response.response = record.one()._asdict()
            except sqlalchemy.exc.NoResultFound:
                raise NotFoundException(description=f&#34;{model_name} with id: {id} not found&#34;)

            response.audit = AuditLog(
                f&#34;Read {table_name} record&#34;,
                action=&#34;READ&#34;,
                current_status=response.response,
                change_parameters={&#34;entity&#34;: model_name, &#34;record_id&#34;: id},
            )
            return response

        @swagger.doc(swagger_docs)
        def get(self, id):
            &#34;&#34;&#34;

            :param id:

            &#34;&#34;&#34;
            return self.process_request(id=id)

    GetSingleEndpoint.__name__ = GetSingleEndpoint.endpoint
    return GetSingleEndpoint


def create_put_single_endpoint_class(table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: Repository):
    &#34;&#34;&#34;

    :param table: dict:
    :param allowed_columns: List:
    :param allowed_columns_map: dict:
    :param extensions: dict:
    :param repository: Repository:

    &#34;&#34;&#34;
    table_slug = table[&#34;slug&#34;]
    table_name = table[&#34;name&#34;]
    model_name = table[&#34;model_name&#34;]
    id_field = table[&#34;id_field&#34;]
    response_schema = get_response_swagger_schema(allowed_columns_map, f&#34;{model_name}PutSingleEndpoint&#34;)
    extension = extensions[&#34;on_create_timestamp&#34;]
    extension_enabled = extension.enabled
    form_class, form_schema_model = _get_form(table[&#34;model_name&#34;], allowed_columns_map, &#34;put&#34;, extensions)
    request_schema = get_put_single_endpoint_schema(model_name, form_schema_model, response_schema)

    class PutSingleEndpoint(AutomaticResource):
        &#34;&#34;&#34; &#34;&#34;&#34;

        route = f&#34;/create/{table_slug}&#34;
        endpoint = f&#34;{model_name}PutSingleEndpoint&#34;
        representations = request_schema
        db_table = table

        def validate_request(self, **args):
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            form = args[&#34;form&#34;]
            if not form.validate():
                raise RequestInvalidFieldSchemaError(simplejson.dumps(form.errors))

        def request(self, **args) -&gt; ResourceResponse:
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            form = args[&#34;form&#34;]
            form_data = form.data
            response = ResourceResponse()
            try:

                params = form_data
                columns = allowed_columns

                if extension_enabled:
                    columns = extension.set_columns(columns)
                if extension_enabled:
                    params = extension.set_field_data(params)

                result = repository.insert_record(table_name, columns, params, returning_field=id_field)
                form_data[id_field] = result

                if extension_enabled:
                    params = extension.unset_field_data(params)

                response.response = form_data

                response.audit = AuditLog(
                    f&#34;Create {table_name} record&#34;,
                    action=&#34;CREATE&#34;,
                    current_status=response.response,
                    change_parameters={**{&#34;entity&#34;: model_name}, **params},
                )

            except sqlalchemy.exc.IntegrityError as e:
                if isinstance(e.orig, psycopg2.errors.UniqueViolation):
                    raise ValidationError(message=e.orig)
                if isinstance(e.orig, psycopg2.errors.ForeignKeyViolation):
                    raise ValidationError(message=e.orig)

            return response

        @swagger.doc(request_schema)
        def put(self):
            &#34;&#34;&#34; &#34;&#34;&#34;
            data = request.json
            try:
                form = form_class(data=data)
            except ValueError:
                raise RequestSchemaError()
            return self.process_request(form=form, data=data)

    PutSingleEndpoint.__name__ = PutSingleEndpoint.endpoint

    return PutSingleEndpoint


def create_post_single_endpoint_class(table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: Repository):
    &#34;&#34;&#34;

    :param table: dict:
    :param allowed_columns: List:
    :param allowed_columns_map: dict:
    :param extensions: dict:
    :param repository: Repository:

    &#34;&#34;&#34;
    table_slug = table[&#34;slug&#34;]
    table_name = table[&#34;name&#34;]
    model_name = table[&#34;model_name&#34;]
    id_field = table[&#34;id_field&#34;]

    response_schema = get_response_swagger_schema(allowed_columns_map, f&#34;{model_name}PostSingleEndpoint&#34;)
    update_extension = extensions[&#34;on_update_timestamp&#34;]
    soft_delete_extension = extensions[&#34;soft_delete&#34;]

    form_class, form_schema_model = _get_form(table[&#34;model_name&#34;], allowed_columns_map, &#34;post&#34;, extensions)

    id_field_where_type = _column_type_to_swagger_type_url(table[&#34;columns&#34;][id_field][&#34;type&#34;])
    request_schema = get_post_single_endpoint_schema(model_name, form_schema_model, response_schema, id_field_where_type)

    class PostSingleEndpoint(AutomaticResource):
        &#34;&#34;&#34; &#34;&#34;&#34;

        route = f&#34;/update/{table_slug}/&lt;{id_field_where_type}id&gt;&#34;
        endpoint = f&#34;{model_name}PostSingleEndpoint&#34;
        representations = request_schema
        db_table = table

        def request(self, **args) -&gt; ResourceResponse:
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            form = args[&#34;form&#34;]
            form_data = form.data
            oid = args[&#34;id&#34;]
            response = ResourceResponse()

            try:
                if update_extension.enabled:
                    form_data = update_extension.set_field_data(form_data)

                _data = {**form_data, **{id_field: oid}}
                repository.update_record(table_name, id_field, oid, _data)

                if update_extension.enabled:
                    form_data = update_extension.unset_field_data(_data)
                response.response = _data

            except sqlalchemy.exc.IntegrityError as e:
                if isinstance(e.orig, psycopg2.errors.UniqueViolation):
                    raise RequestInvalidFieldSchemaError(message=e.orig)
                if isinstance(e.orig, psycopg2.errors.ForeignKeyViolation):
                    raise RequestInvalidFieldSchemaError(message=e.orig)

            response.audit = AuditLog(
                f&#34;Update {table_name} record&#34;,
                action=&#34;UPDATE&#34;,
                current_status=response.response,
                prev_status=args[&#34;validation_output&#34;],
                change_parameters={**{&#34;entity&#34;: model_name, f&#34;{id_field}&#34;: oid}, **form_data},
            )

            return response

        def validate_request(self, **args):
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            form = args[&#34;form&#34;]
            id = args[&#34;id&#34;]
            try:
                logger.debug(&#34;Check entity exists&#34;, extra=args)

                query = {f&#34;{id_field}&#34;: {&#34;op&#34;: &#34;=&#34;, &#34;value&#34;: id}}
                query_values = {f&#34;{id_field}&#34;: id}

                if soft_delete_extension.enabled:
                    query, query_values = soft_delete_extension.add_query_filter(query, query_values)

                record = repository.fetch_by(table_name, [&#34;*&#34;], query, query_values)

                if not form.validate():
                    raise RequestInvalidFieldSchemaError(simplejson.dumps(form.errors))

                return record.one()._asdict()
            except sqlalchemy.exc.NoResultFound:
                raise NotFoundException(description=f&#34;{model_name} with id: {id} not found&#34;)
            except JsonSchemaValidationError:
                raise RequestSchemaError()

        @swagger.doc(request_schema)
        def post(self, id):
            &#34;&#34;&#34;

            :param id:

            &#34;&#34;&#34;
            data = request.json
            form = form_class(data=data)
            return self.process_request(form=form, data=data, id=id)

    PostSingleEndpoint.__name__ = PostSingleEndpoint.endpoint

    return PostSingleEndpoint


def create_delete_single_endpoint_class(table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: Repository):
    &#34;&#34;&#34;

    :param table: dict:
    :param allowed_columns: List:
    :param allowed_columns_map: dict:
    :param extensions: dict:
    :param repository: Repository:

    &#34;&#34;&#34;
    table_slug = table[&#34;slug&#34;]
    table_name = table[&#34;name&#34;]
    model_name = table[&#34;model_name&#34;]
    id_field = table[&#34;id_field&#34;]

    id_field_where_type = _column_type_to_swagger_type_url(table[&#34;columns&#34;][id_field][&#34;type&#34;])

    soft_delete_extension = extensions[&#34;soft_delete&#34;]
    request_schema = get_delete_single_endpoint_schema(model_name, id_field_where_type)

    class DeleteSingleEndpoint(AutomaticResource):
        &#34;&#34;&#34; &#34;&#34;&#34;

        route = f&#34;/delete/{table_slug}/&lt;{id_field_where_type}id&gt;&#34;
        endpoint = f&#34;{model_name}DeleteSingleEndpoint&#34;
        representations = request_schema
        db_table = table

        def request(self, **args) -&gt; ResourceResponse:
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            id = args[&#34;id&#34;]
            response = ResourceResponse()
            response.response = {&#34;code&#34;: 500, &#34;message&#34;: &#34;error&#34;, &#34;errors&#34;: []}

            try:
                if soft_delete_extension.enabled:
                    response = soft_delete_extension.soft_delete(id_field, id, response)

                    response.audit = AuditLog(
                        f&#34;Delete {table_name} record&#34;,
                        action=&#34;SOFT DELETE&#34;,
                        current_status={&#34;deleted&#34;: &#34;deleted&#34;},
                        prev_status=args[&#34;validation_output&#34;],
                        change_parameters={&#34;entity&#34;: model_name, &#34;id&#34;: id},
                    )
                else:
                    repository.delete_record(table_name, id_field, id)
                    response.response[&#34;message&#34;] = &#34;ok&#34;
                    response.response[&#34;code&#34;] = 200

                    response.audit = AuditLog(
                        f&#34;Delete {table_name} record&#34;,
                        action=&#34;DELETE&#34;,
                        current_status={&#34;deleted&#34;: &#34;deleted&#34;},
                        prev_status=args[&#34;validation_output&#34;],
                        change_parameters={&#34;entity&#34;: model_name, &#34;id&#34;: id},
                    )

            except sqlalchemy.exc.IntegrityError as e:
                if isinstance(e.orig, psycopg2.errors.ForeignKeyViolation):
                    response.response[&#34;errors&#34;].append(f&#34;ForeignKeyViolation : {e.orig}&#34;)
                    response.response[&#34;code&#34;] = 400
                else:
                    response.response[&#34;errors&#34;].append(f&#34;IntegrityError : {e.orig}&#34;)
                    response.response[&#34;code&#34;] = 500

            response.http_code = response.response[&#34;code&#34;]

            return response

        def validate_request(self, **args):
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            oid = args[&#34;id&#34;]
            try:
                logger.debug(&#34;Check entity exists&#34;, extra=args)
                query = {f&#34;{id_field}&#34;: {&#34;op&#34;: &#34;=&#34;, &#34;value&#34;: oid}}
                query_values = {f&#34;{id_field}&#34;: oid}

                if soft_delete_extension.enabled:
                    query, query_values, soft_delete_extension.add_query_filter(query, query_values)

                record = repository.fetch_by(table_name, [&#34;*&#34;], query, query_values)

                return record.one()._asdict()
            except sqlalchemy.exc.NoResultFound:
                raise NotFoundException(description=f&#34;{model_name} with id: {oid} not found&#34;)

        @swagger.doc(request_schema)
        def delete(self, id):
            &#34;&#34;&#34;

            :param id:

            &#34;&#34;&#34;
            return self.process_request(id=id)

    DeleteSingleEndpoint.__name__ = DeleteSingleEndpoint.endpoint

    return DeleteSingleEndpoint


def create_get_list_endpoint_class(  # noqa C901
    table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: Repository
):
    &#34;&#34;&#34;

    :param # noqa C901table: dict:
    :param allowed_columns: List:
    :param allowed_columns_map: dict:
    :param extensions: dict:
    :param repository: Repository:

    &#34;&#34;&#34;
    table_slug = table[&#34;slug&#34;]
    table_name = table[&#34;name&#34;]
    model_name = table[&#34;model_name&#34;]
    id_field = table[&#34;id_field&#34;]

    request_schema_query_filters = get_list_filtered_request_swagger_schema(model_name, allowed_columns_map)
    response_schema_query_filters = get_list_filtered_request_swagger_schema(model_name, allowed_columns_map)
    response_schema = get_list_filtered_response_swagger_schema(allowed_columns_map, response_schema_query_filters, f&#34;{model_name}GetListEndpoint&#34;)
    swagger_schema = get_get_list_endpoint_schema(model_name, response_schema, request_schema_query_filters)
    filter_schema = get_filter_schema(model_name).definitions()
    order_schema = get_order_schema(model_name).definitions()
    size_schema = get_size_schema(model_name).definitions()
    soft_delete_extension = extensions[&#34;soft_delete&#34;]

    class GetListEndpoint(AutomaticResource):
        &#34;&#34;&#34; &#34;&#34;&#34;

        route = f&#34;/read/{inflector.plural(table_slug)}&#34;
        endpoint = f&#34;{model_name}GetListEndpoint&#34;
        representations = swagger_schema
        db_table = table

        def validate_request(self, **args):
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            query = {}
            errors = {}
            schema = filter_schema
            for parameter_name in allowed_columns_map.keys():
                self.validate_query_parameter(errors, parameter_name, query, schema)

            parameter_name = &#34;order&#34;
            schema = order_schema
            self.validate_query_parameter(errors, parameter_name, query, schema, default={&#34;field&#34;: [id_field], &#34;direction&#34;: &#34;asc&#34;})

            parameter_name = &#34;size&#34;
            schema = size_schema
            self.validate_query_parameter(errors, parameter_name, query, schema, default={&#34;limit&#34;: 100, &#34;offset&#34;: 0})

            if len(errors.keys()) &gt; 0:
                raise ValidationError(errors)

            return query

        def validate_query_parameter(self, errors, parameter_name, query, schema, default=None):
            &#34;&#34;&#34;

            :param errors:
            :param parameter_name:
            :param query:
            :param schema:
            :param default:  (Default value = None)

            &#34;&#34;&#34;
            try:
                value = request.args.get(parameter_name)
                if value is not None:
                    json_value = simplejson.loads(value)
                    json_swagger_schema_validator(json_value, schema)
                    query[parameter_name] = json_value

                if value is None and default is not None:
                    json_swagger_schema_validator(default, schema)
                    query[parameter_name] = default
            except JsonSchemaValidationError as e:
                error_msg = e.message.replace(&#34;\n&#34;, &#34; &#34;)
                if parameter_name not in errors.keys():
                    errors[parameter_name] = []
                errors[parameter_name].append(f&#34;&#39;{parameter_name}&#39; query parameter is not valid: {error_msg}&#34;)
            except JSONDecodeError as e:
                if parameter_name not in errors.keys():
                    errors[parameter_name] = []
                errors[parameter_name].append(f&#34;&#39;{parameter_name}&#39; query parameter seem to be a malformed JSON: {e.msg}&#34;)
            except Exception:
                if parameter_name not in errors.keys():
                    errors[parameter_name] = []
                errors[parameter_name].append(f&#34;&#39;{parameter_name}&#39; query parameter seem to be a malformed JSON&#34;)

        def request(self, **args) -&gt; ResourceResponse:
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            query = args[&#34;validation_output&#34;]
            if soft_delete_extension.enabled:
                query, _qv = soft_delete_extension.add_query_filter(query, {})
            query_no_limit = query.copy()
            del query_no_limit[&#34;size&#34;]
            query_no_limit_params = {k: v[&#34;value&#34;] for k, v in query_no_limit.items() if &#34;op&#34; in v}
            count_sql = create_select_filtered_paginated_query_count(table_name, query_no_limit, id_field)

            count_record = repository.execute(count_sql, query_no_limit_params).one()._asdict()
            count = count_record.get(&#34;count&#34;)

            response = ResourceResponse()
            data = {}

            if count &gt; 0:
                query_params = {k: v[&#34;value&#34;] for k, v in query.items() if &#34;op&#34; in v}
                sql = create_select_filtered_paginated_ordered_query(table_name, allowed_columns, query)
                record = repository.execute(sql, query_params)
                data = record.fetchall()

            if soft_delete_extension.enabled:
                query = soft_delete_extension.unset_field_data(query)

            response.response = {&#34;data&#34;: data, &#34;_meta&#34;: {**query, **{&#34;total_records&#34;: count}}}

            if count == 0:
                response.http_code = 404

            response.audit = AuditLog(
                f&#34;Read List {table_name} record&#34;,
                action=&#34;READ&#34;,
                current_status={&#34;deleted&#34;: &#34;deleted&#34;},
                prev_status=args[&#34;validation_output&#34;],
                change_parameters={&#34;entity&#34;: model_name},
            )

            return response

        @swagger.doc(swagger_schema)
        def get(self):
            &#34;&#34;&#34; &#34;&#34;&#34;
            return self.process_request()

    GetListEndpoint.__name__ = GetListEndpoint.endpoint
    return GetListEndpoint


def create_put_list_endpoint_class(  # noqa C901
    table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: Repository
):
    &#34;&#34;&#34;

    :param # noqa C901table: dict:
    :param allowed_columns: List:
    :param allowed_columns_map: dict:
    :param extensions: dict:
    :param repository: Repository:

    &#34;&#34;&#34;
    table_slug = table[&#34;slug&#34;]
    table_name = table[&#34;name&#34;]
    model_name = table[&#34;model_name&#34;]
    id_field = table[&#34;id_field&#34;]

    create_extension = extensions[&#34;on_create_timestamp&#34;]

    form_class, form_schema_model = _get_form(table[&#34;model_name&#34;], allowed_columns_map, &#34;putList&#34;, extensions)

    request_schema = get_put_list_endpoint_schema(model_name, form_schema_model)

    columns = allowed_columns
    if create_extension.enabled:
        columns += [create_extension.config[&#34;default_field&#34;]]

    class PutListEndpoint(AutomaticResource):
        &#34;&#34;&#34; &#34;&#34;&#34;

        route = f&#34;/create/{inflector.plural(table_slug)}&#34;
        endpoint = f&#34;{model_name}PutListEndpoint&#34;
        representations = request_schema
        db_table = table

        def validate_request(self, **args):
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            if hasattr(form_schema_model, &#34;maxItems&#34;) and len(args[&#34;data&#34;]) &gt; form_schema_model.maxItems:
                raise ValidationError(message=f&#34;Body too large, max items: {form_schema_model.maxItems}&#34;)
            if hasattr(form_schema_model, &#34;minItems&#34;) and len(args[&#34;data&#34;]) &lt; form_schema_model.minItems:
                raise ValidationError(message=f&#34;Body too small, min items: {form_schema_model.minItems}&#34;)
            forms = args[&#34;form&#34;]
            errors = {}
            for i, form in enumerate(forms):
                if not form.validate():
                    errors[i] = form.errors

            if len(errors.keys()) &gt; 0:
                raise ValidationError(message=simplejson.dumps(errors))

        def request(self, **args) -&gt; ResourceResponse:
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            forms = args[&#34;form&#34;]
            form_data = []
            for form in forms:
                _form_data = form.data
                if create_extension.enabled:
                    _form_data = create_extension.set_field_data(_form_data)
                form_data.append(_form_data)
            # form_data = [form.data for form in forms]
            response = ResourceResponse()
            response.response = {&#34;message&#34;: &#34;error&#34;, &#34;details&#34;: []}

            try:

                result = repository.insert_batch(table_name, columns, form_data, returning_field=id_field)
                response.response[&#34;message&#34;] = f&#34;Affected rows: {result}&#34;
                response.response[&#34;code&#34;] = 200
                response.http_code = 200
            except sqlalchemy.exc.IntegrityError as e:
                if isinstance(e.orig, psycopg2.errors.UniqueViolation):
                    raise ValidationError(message=e.orig)
                if isinstance(e.orig, psycopg2.errors.ForeignKeyViolation):
                    raise ValidationError(message=e.orig)

            return response

        @swagger.doc(request_schema)
        def put(self):
            &#34;&#34;&#34; &#34;&#34;&#34;
            data = request.json
            form = [form_class(data=item) for item in data]
            return self.process_request(form=form, data=data)

    PutListEndpoint.__name__ = PutListEndpoint.endpoint

    return PutListEndpoint


def create_post_list_endpoint_class(  # noqa C901
    table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: Repository
):
    &#34;&#34;&#34;

    :param # noqa C901table: dict:
    :param allowed_columns: List:
    :param allowed_columns_map: dict:
    :param extensions: dict:
    :param repository: Repository:

    &#34;&#34;&#34;
    table_slug = table[&#34;slug&#34;]
    table_name = table[&#34;name&#34;]
    model_name = table[&#34;model_name&#34;]
    id_field = table[&#34;id_field&#34;]
    form_class, form_schema_model = _get_form(model_name, allowed_columns_map, &#34;postList&#34;, extensions)

    request_schema = get_post_list_endpoint_schema(model_name, form_schema_model)
    extension = extensions[&#34;on_update_timestamp&#34;]

    class PostListEndpoint(AutomaticResource):
        &#34;&#34;&#34; &#34;&#34;&#34;

        route = f&#34;/update/{inflector.plural(table_slug)}&#34;
        endpoint = f&#34;{model_name}PostListEndpoint&#34;
        representations = request_schema
        db_table = table

        def validate_request(self, **args):
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            forms = args[&#34;form&#34;]
            if hasattr(args[&#34;data&#34;], &#34;maxItems&#34;) and len(args[&#34;data&#34;]) &gt; form_schema_model.maxItems:
                raise ValidationError(message=f&#34;Body too large, max items: {form_schema_model.maxItems}&#34;)
            if hasattr(args[&#34;data&#34;], &#34;minItems&#34;) and len(args[&#34;data&#34;]) &lt; form_schema_model.minItems:
                raise ValidationError(message=f&#34;Body too small, min items: {form_schema_model.minItems}&#34;)

            errors = {}
            ids = []
            for i, form in enumerate(forms):
                _data = form.data
                ids.append(_data[id_field])
                if not form.validate():
                    errors[i] = form.errors

            ids_check_sql = _MAGIC_QUERIES[repository.db_dialect][&#34;get_ids_not_in_table_from_list&#34;](
                {
                    &#34;values&#34;: [f&#34;:{id}&#34; for id in ids],
                    &#34;id_field&#34;: id_field,
                    &#34;table&#34;: table_name,
                    &#34;where&#34;: f&#39;WHERE {extension.config[&#34;default_field&#34;]} IS NULL&#39; if extension.enabled else &#34;&#34;,
                }
            )

            ids_check = repository.execute(ids_check_sql, {str(id): id for id in ids})
            not_found = ids_check.fetchall()
            if len(not_found) &gt; 0:
                errors = {**errors, **{str(x[0]): &#34;id not found&#34; for x in not_found}}

            if len(errors.keys()) &gt; 0:
                raise ValidationError(message=simplejson.dumps(errors))

        def request(self, **args) -&gt; ResourceResponse:
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            forms = args[&#34;form&#34;]
            form_data = []
            for form in forms:
                _form_data = form.data
                if extension.enabled:
                    _form_data = extension.set_field_data(_form_data)

                form_data.append(_form_data)
            response = ResourceResponse()
            try:
                repository.update_batch(table_name, form_data, where_field=id_field)
                response.response = form_data
            except sqlalchemy.exc.IntegrityError as e:
                if isinstance(e.orig, psycopg2.errors.UniqueViolation):
                    raise ValidationError(message=e.orig)
                if isinstance(e.orig, psycopg2.errors.ForeignKeyViolation):
                    raise ValidationError(message=e.orig)

            return response

        @swagger.doc(request_schema)
        def post(self):
            &#34;&#34;&#34; &#34;&#34;&#34;
            data = request.json
            form = [form_class(data=item) for item in data]
            return self.process_request(form=form, data=data)

    PostListEndpoint.__name__ = PostListEndpoint.endpoint

    return PostListEndpoint


def create_delete_list_endpoint_class(table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: Repository):
    &#34;&#34;&#34;

    :param table: dict:
    :param allowed_columns: List:
    :param allowed_columns_map: dict:
    :param extensions: dict:
    :param repository: Repository:

    &#34;&#34;&#34;
    table_slug = table[&#34;slug&#34;]
    table_name = table[&#34;name&#34;]
    model_name = table[&#34;model_name&#34;]
    id_field = table[&#34;id_field&#34;]

    id_field_where_type = python_to_swagger_types(table[&#34;columns&#34;][id_field][&#34;type&#34;].python_type.__name__)

    request_body_schema = create_swagger_type_from_dict(
        f&#34;{model_name}DeleteListRequestSchema&#34;, {&#34;type&#34;: &#34;array&#34;, &#34;description&#34;: &#34;Id list&#34;, &#34;items&#34;: {&#34;type&#34;: id_field_where_type}}
    )
    request_schema = get_delete_list_endpoint_schema(model_name, request_body_schema)

    extension = extensions[&#34;soft_delete&#34;]

    class DeleteListEndpoint(AutomaticResource):
        &#34;&#34;&#34; &#34;&#34;&#34;

        route = f&#34;/delete/{inflector.plural(table_slug)}&#34;
        endpoint = f&#34;{model_name}DeleteListEndpoint&#34;
        representations = request_schema
        db_table = table

        def validate_request(self, **args):
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            ids = args[&#34;data&#34;]
            errors = {}
            try:
                json_swagger_schema_validator(ids, request_body_schema.definitions())
            except JsonSchemaValidationError as e:
                raise ValidationError(message=e)

            ids_check_sql = _MAGIC_QUERIES[DB_DIALECT_POSTGRES][&#34;get_ids_not_in_table_from_list&#34;](
                {
                    &#34;values&#34;: [f&#34;:{id}&#34; for id in ids],
                    &#34;id_field&#34;: id_field,
                    &#34;table&#34;: table_name,
                    &#34;where&#34;: f&#39;WHERE {extension.config[&#34;default_field&#34;]} IS NULL&#39; if extension.enabled else &#34;&#34;,
                }
            )

            ids_check = repository.execute(ids_check_sql, {str(id): id for id in ids})
            not_found = ids_check.fetchall()
            if len(not_found) &gt; 0:
                errors = {str(x[0]): &#34;id not found&#34; for x in not_found}
            if len(errors.keys()) &gt; 0:
                raise ValidationError(message=simplejson.dumps(errors))

        def request(self, **args) -&gt; ResourceResponse:
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            data = args[&#34;data&#34;]

            response = ResourceResponse()
            try:
                if extension.enabled:
                    extension.soft_delete_batch(table_name, extension.config[&#34;default_field&#34;], id_field, data)
                else:
                    repository.delete_batch(table_name, data)
                response.response = &#34;ok&#34;
            except sqlalchemy.exc.IntegrityError as e:
                if isinstance(e.orig, psycopg2.errors.UniqueViolation):
                    raise ValidationError(message=e.orig)
                if isinstance(e.orig, psycopg2.errors.ForeignKeyViolation):
                    raise ValidationError(message=e.orig)

            return response

        @swagger.doc(request_schema)
        def delete(self):
            &#34;&#34;&#34; &#34;&#34;&#34;
            data = request.json
            return self.process_request(data=data)

    DeleteListEndpoint.__name__ = DeleteListEndpoint.endpoint

    return DeleteListEndpoint</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="chillapi.endpoints.tables.create_delete_list_endpoint_class"><code class="name flex">
<span>def <span class="ident">create_delete_list_endpoint_class</span></span>(<span>table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: <a title="chillapi.abc.Repository" href="../abc.html#chillapi.abc.Repository">Repository</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>:param table: dict:
:param allowed_columns: List:
:param allowed_columns_map: dict:
:param extensions: dict:
:param repository: Repository:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_delete_list_endpoint_class(table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: Repository):
    &#34;&#34;&#34;

    :param table: dict:
    :param allowed_columns: List:
    :param allowed_columns_map: dict:
    :param extensions: dict:
    :param repository: Repository:

    &#34;&#34;&#34;
    table_slug = table[&#34;slug&#34;]
    table_name = table[&#34;name&#34;]
    model_name = table[&#34;model_name&#34;]
    id_field = table[&#34;id_field&#34;]

    id_field_where_type = python_to_swagger_types(table[&#34;columns&#34;][id_field][&#34;type&#34;].python_type.__name__)

    request_body_schema = create_swagger_type_from_dict(
        f&#34;{model_name}DeleteListRequestSchema&#34;, {&#34;type&#34;: &#34;array&#34;, &#34;description&#34;: &#34;Id list&#34;, &#34;items&#34;: {&#34;type&#34;: id_field_where_type}}
    )
    request_schema = get_delete_list_endpoint_schema(model_name, request_body_schema)

    extension = extensions[&#34;soft_delete&#34;]

    class DeleteListEndpoint(AutomaticResource):
        &#34;&#34;&#34; &#34;&#34;&#34;

        route = f&#34;/delete/{inflector.plural(table_slug)}&#34;
        endpoint = f&#34;{model_name}DeleteListEndpoint&#34;
        representations = request_schema
        db_table = table

        def validate_request(self, **args):
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            ids = args[&#34;data&#34;]
            errors = {}
            try:
                json_swagger_schema_validator(ids, request_body_schema.definitions())
            except JsonSchemaValidationError as e:
                raise ValidationError(message=e)

            ids_check_sql = _MAGIC_QUERIES[DB_DIALECT_POSTGRES][&#34;get_ids_not_in_table_from_list&#34;](
                {
                    &#34;values&#34;: [f&#34;:{id}&#34; for id in ids],
                    &#34;id_field&#34;: id_field,
                    &#34;table&#34;: table_name,
                    &#34;where&#34;: f&#39;WHERE {extension.config[&#34;default_field&#34;]} IS NULL&#39; if extension.enabled else &#34;&#34;,
                }
            )

            ids_check = repository.execute(ids_check_sql, {str(id): id for id in ids})
            not_found = ids_check.fetchall()
            if len(not_found) &gt; 0:
                errors = {str(x[0]): &#34;id not found&#34; for x in not_found}
            if len(errors.keys()) &gt; 0:
                raise ValidationError(message=simplejson.dumps(errors))

        def request(self, **args) -&gt; ResourceResponse:
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            data = args[&#34;data&#34;]

            response = ResourceResponse()
            try:
                if extension.enabled:
                    extension.soft_delete_batch(table_name, extension.config[&#34;default_field&#34;], id_field, data)
                else:
                    repository.delete_batch(table_name, data)
                response.response = &#34;ok&#34;
            except sqlalchemy.exc.IntegrityError as e:
                if isinstance(e.orig, psycopg2.errors.UniqueViolation):
                    raise ValidationError(message=e.orig)
                if isinstance(e.orig, psycopg2.errors.ForeignKeyViolation):
                    raise ValidationError(message=e.orig)

            return response

        @swagger.doc(request_schema)
        def delete(self):
            &#34;&#34;&#34; &#34;&#34;&#34;
            data = request.json
            return self.process_request(data=data)

    DeleteListEndpoint.__name__ = DeleteListEndpoint.endpoint

    return DeleteListEndpoint</code></pre>
</details>
</dd>
<dt id="chillapi.endpoints.tables.create_delete_single_endpoint_class"><code class="name flex">
<span>def <span class="ident">create_delete_single_endpoint_class</span></span>(<span>table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: <a title="chillapi.abc.Repository" href="../abc.html#chillapi.abc.Repository">Repository</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>:param table: dict:
:param allowed_columns: List:
:param allowed_columns_map: dict:
:param extensions: dict:
:param repository: Repository:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_delete_single_endpoint_class(table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: Repository):
    &#34;&#34;&#34;

    :param table: dict:
    :param allowed_columns: List:
    :param allowed_columns_map: dict:
    :param extensions: dict:
    :param repository: Repository:

    &#34;&#34;&#34;
    table_slug = table[&#34;slug&#34;]
    table_name = table[&#34;name&#34;]
    model_name = table[&#34;model_name&#34;]
    id_field = table[&#34;id_field&#34;]

    id_field_where_type = _column_type_to_swagger_type_url(table[&#34;columns&#34;][id_field][&#34;type&#34;])

    soft_delete_extension = extensions[&#34;soft_delete&#34;]
    request_schema = get_delete_single_endpoint_schema(model_name, id_field_where_type)

    class DeleteSingleEndpoint(AutomaticResource):
        &#34;&#34;&#34; &#34;&#34;&#34;

        route = f&#34;/delete/{table_slug}/&lt;{id_field_where_type}id&gt;&#34;
        endpoint = f&#34;{model_name}DeleteSingleEndpoint&#34;
        representations = request_schema
        db_table = table

        def request(self, **args) -&gt; ResourceResponse:
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            id = args[&#34;id&#34;]
            response = ResourceResponse()
            response.response = {&#34;code&#34;: 500, &#34;message&#34;: &#34;error&#34;, &#34;errors&#34;: []}

            try:
                if soft_delete_extension.enabled:
                    response = soft_delete_extension.soft_delete(id_field, id, response)

                    response.audit = AuditLog(
                        f&#34;Delete {table_name} record&#34;,
                        action=&#34;SOFT DELETE&#34;,
                        current_status={&#34;deleted&#34;: &#34;deleted&#34;},
                        prev_status=args[&#34;validation_output&#34;],
                        change_parameters={&#34;entity&#34;: model_name, &#34;id&#34;: id},
                    )
                else:
                    repository.delete_record(table_name, id_field, id)
                    response.response[&#34;message&#34;] = &#34;ok&#34;
                    response.response[&#34;code&#34;] = 200

                    response.audit = AuditLog(
                        f&#34;Delete {table_name} record&#34;,
                        action=&#34;DELETE&#34;,
                        current_status={&#34;deleted&#34;: &#34;deleted&#34;},
                        prev_status=args[&#34;validation_output&#34;],
                        change_parameters={&#34;entity&#34;: model_name, &#34;id&#34;: id},
                    )

            except sqlalchemy.exc.IntegrityError as e:
                if isinstance(e.orig, psycopg2.errors.ForeignKeyViolation):
                    response.response[&#34;errors&#34;].append(f&#34;ForeignKeyViolation : {e.orig}&#34;)
                    response.response[&#34;code&#34;] = 400
                else:
                    response.response[&#34;errors&#34;].append(f&#34;IntegrityError : {e.orig}&#34;)
                    response.response[&#34;code&#34;] = 500

            response.http_code = response.response[&#34;code&#34;]

            return response

        def validate_request(self, **args):
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            oid = args[&#34;id&#34;]
            try:
                logger.debug(&#34;Check entity exists&#34;, extra=args)
                query = {f&#34;{id_field}&#34;: {&#34;op&#34;: &#34;=&#34;, &#34;value&#34;: oid}}
                query_values = {f&#34;{id_field}&#34;: oid}

                if soft_delete_extension.enabled:
                    query, query_values, soft_delete_extension.add_query_filter(query, query_values)

                record = repository.fetch_by(table_name, [&#34;*&#34;], query, query_values)

                return record.one()._asdict()
            except sqlalchemy.exc.NoResultFound:
                raise NotFoundException(description=f&#34;{model_name} with id: {oid} not found&#34;)

        @swagger.doc(request_schema)
        def delete(self, id):
            &#34;&#34;&#34;

            :param id:

            &#34;&#34;&#34;
            return self.process_request(id=id)

    DeleteSingleEndpoint.__name__ = DeleteSingleEndpoint.endpoint

    return DeleteSingleEndpoint</code></pre>
</details>
</dd>
<dt id="chillapi.endpoints.tables.create_get_list_endpoint_class"><code class="name flex">
<span>def <span class="ident">create_get_list_endpoint_class</span></span>(<span>table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: <a title="chillapi.abc.Repository" href="../abc.html#chillapi.abc.Repository">Repository</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>:param # noqa C901table: dict:
:param allowed_columns: List:
:param allowed_columns_map: dict:
:param extensions: dict:
:param repository: Repository:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_get_list_endpoint_class(  # noqa C901
    table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: Repository
):
    &#34;&#34;&#34;

    :param # noqa C901table: dict:
    :param allowed_columns: List:
    :param allowed_columns_map: dict:
    :param extensions: dict:
    :param repository: Repository:

    &#34;&#34;&#34;
    table_slug = table[&#34;slug&#34;]
    table_name = table[&#34;name&#34;]
    model_name = table[&#34;model_name&#34;]
    id_field = table[&#34;id_field&#34;]

    request_schema_query_filters = get_list_filtered_request_swagger_schema(model_name, allowed_columns_map)
    response_schema_query_filters = get_list_filtered_request_swagger_schema(model_name, allowed_columns_map)
    response_schema = get_list_filtered_response_swagger_schema(allowed_columns_map, response_schema_query_filters, f&#34;{model_name}GetListEndpoint&#34;)
    swagger_schema = get_get_list_endpoint_schema(model_name, response_schema, request_schema_query_filters)
    filter_schema = get_filter_schema(model_name).definitions()
    order_schema = get_order_schema(model_name).definitions()
    size_schema = get_size_schema(model_name).definitions()
    soft_delete_extension = extensions[&#34;soft_delete&#34;]

    class GetListEndpoint(AutomaticResource):
        &#34;&#34;&#34; &#34;&#34;&#34;

        route = f&#34;/read/{inflector.plural(table_slug)}&#34;
        endpoint = f&#34;{model_name}GetListEndpoint&#34;
        representations = swagger_schema
        db_table = table

        def validate_request(self, **args):
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            query = {}
            errors = {}
            schema = filter_schema
            for parameter_name in allowed_columns_map.keys():
                self.validate_query_parameter(errors, parameter_name, query, schema)

            parameter_name = &#34;order&#34;
            schema = order_schema
            self.validate_query_parameter(errors, parameter_name, query, schema, default={&#34;field&#34;: [id_field], &#34;direction&#34;: &#34;asc&#34;})

            parameter_name = &#34;size&#34;
            schema = size_schema
            self.validate_query_parameter(errors, parameter_name, query, schema, default={&#34;limit&#34;: 100, &#34;offset&#34;: 0})

            if len(errors.keys()) &gt; 0:
                raise ValidationError(errors)

            return query

        def validate_query_parameter(self, errors, parameter_name, query, schema, default=None):
            &#34;&#34;&#34;

            :param errors:
            :param parameter_name:
            :param query:
            :param schema:
            :param default:  (Default value = None)

            &#34;&#34;&#34;
            try:
                value = request.args.get(parameter_name)
                if value is not None:
                    json_value = simplejson.loads(value)
                    json_swagger_schema_validator(json_value, schema)
                    query[parameter_name] = json_value

                if value is None and default is not None:
                    json_swagger_schema_validator(default, schema)
                    query[parameter_name] = default
            except JsonSchemaValidationError as e:
                error_msg = e.message.replace(&#34;\n&#34;, &#34; &#34;)
                if parameter_name not in errors.keys():
                    errors[parameter_name] = []
                errors[parameter_name].append(f&#34;&#39;{parameter_name}&#39; query parameter is not valid: {error_msg}&#34;)
            except JSONDecodeError as e:
                if parameter_name not in errors.keys():
                    errors[parameter_name] = []
                errors[parameter_name].append(f&#34;&#39;{parameter_name}&#39; query parameter seem to be a malformed JSON: {e.msg}&#34;)
            except Exception:
                if parameter_name not in errors.keys():
                    errors[parameter_name] = []
                errors[parameter_name].append(f&#34;&#39;{parameter_name}&#39; query parameter seem to be a malformed JSON&#34;)

        def request(self, **args) -&gt; ResourceResponse:
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            query = args[&#34;validation_output&#34;]
            if soft_delete_extension.enabled:
                query, _qv = soft_delete_extension.add_query_filter(query, {})
            query_no_limit = query.copy()
            del query_no_limit[&#34;size&#34;]
            query_no_limit_params = {k: v[&#34;value&#34;] for k, v in query_no_limit.items() if &#34;op&#34; in v}
            count_sql = create_select_filtered_paginated_query_count(table_name, query_no_limit, id_field)

            count_record = repository.execute(count_sql, query_no_limit_params).one()._asdict()
            count = count_record.get(&#34;count&#34;)

            response = ResourceResponse()
            data = {}

            if count &gt; 0:
                query_params = {k: v[&#34;value&#34;] for k, v in query.items() if &#34;op&#34; in v}
                sql = create_select_filtered_paginated_ordered_query(table_name, allowed_columns, query)
                record = repository.execute(sql, query_params)
                data = record.fetchall()

            if soft_delete_extension.enabled:
                query = soft_delete_extension.unset_field_data(query)

            response.response = {&#34;data&#34;: data, &#34;_meta&#34;: {**query, **{&#34;total_records&#34;: count}}}

            if count == 0:
                response.http_code = 404

            response.audit = AuditLog(
                f&#34;Read List {table_name} record&#34;,
                action=&#34;READ&#34;,
                current_status={&#34;deleted&#34;: &#34;deleted&#34;},
                prev_status=args[&#34;validation_output&#34;],
                change_parameters={&#34;entity&#34;: model_name},
            )

            return response

        @swagger.doc(swagger_schema)
        def get(self):
            &#34;&#34;&#34; &#34;&#34;&#34;
            return self.process_request()

    GetListEndpoint.__name__ = GetListEndpoint.endpoint
    return GetListEndpoint</code></pre>
</details>
</dd>
<dt id="chillapi.endpoints.tables.create_get_single_endpoint_class"><code class="name flex">
<span>def <span class="ident">create_get_single_endpoint_class</span></span>(<span>table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: <a title="chillapi.abc.Repository" href="../abc.html#chillapi.abc.Repository">Repository</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>:param table: dict:
:param allowed_columns: List:
:param allowed_columns_map: dict:
:param extensions: dict:
:param repository: Repository:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_get_single_endpoint_class(table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: Repository):
    &#34;&#34;&#34;

    :param table: dict:
    :param allowed_columns: List:
    :param allowed_columns_map: dict:
    :param extensions: dict:
    :param repository: Repository:

    &#34;&#34;&#34;
    table_slug = table[&#34;slug&#34;]
    table_name = table[&#34;name&#34;]
    model_name = table[&#34;model_name&#34;]
    id_field = table[&#34;id_field&#34;]

    id_field_where_type = _column_type_to_swagger_type_url(table[&#34;columns&#34;][id_field][&#34;type&#34;])
    response_schema = get_response_swagger_schema(allowed_columns_map, f&#34;{model_name}GetSingleEndpoint&#34;)
    soft_delete_extension = extensions[&#34;soft_delete&#34;]
    swagger_docs = get_get_single_endpoint_schema(model_name, id_field_where_type, response_schema)

    class GetSingleEndpoint(AutomaticResource):
        &#34;&#34;&#34; &#34;&#34;&#34;

        route = f&#34;/read/{table_slug}/&lt;{id_field_where_type}id&gt;&#34;
        endpoint = f&#34;{model_name}GetSingleEndpoint&#34;
        representations = swagger_docs
        db_table = table

        def request(self, **args) -&gt; ResourceResponse:
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            id = args[&#34;id&#34;]
            try:
                response = ResourceResponse()

                query = {id_field: {&#34;op&#34;: &#34;=&#34;, &#34;value&#34;: id}}
                query_values = {id_field: id}

                if soft_delete_extension.enabled:
                    query, query_values, soft_delete_extension.add_query_filter(query, query_values)

                record = repository.fetch_by(
                    table_name,
                    allowed_columns,
                    query,
                    query_values,
                )

                response.response = record.one()._asdict()
            except sqlalchemy.exc.NoResultFound:
                raise NotFoundException(description=f&#34;{model_name} with id: {id} not found&#34;)

            response.audit = AuditLog(
                f&#34;Read {table_name} record&#34;,
                action=&#34;READ&#34;,
                current_status=response.response,
                change_parameters={&#34;entity&#34;: model_name, &#34;record_id&#34;: id},
            )
            return response

        @swagger.doc(swagger_docs)
        def get(self, id):
            &#34;&#34;&#34;

            :param id:

            &#34;&#34;&#34;
            return self.process_request(id=id)

    GetSingleEndpoint.__name__ = GetSingleEndpoint.endpoint
    return GetSingleEndpoint</code></pre>
</details>
</dd>
<dt id="chillapi.endpoints.tables.create_post_list_endpoint_class"><code class="name flex">
<span>def <span class="ident">create_post_list_endpoint_class</span></span>(<span>table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: <a title="chillapi.abc.Repository" href="../abc.html#chillapi.abc.Repository">Repository</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>:param # noqa C901table: dict:
:param allowed_columns: List:
:param allowed_columns_map: dict:
:param extensions: dict:
:param repository: Repository:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_post_list_endpoint_class(  # noqa C901
    table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: Repository
):
    &#34;&#34;&#34;

    :param # noqa C901table: dict:
    :param allowed_columns: List:
    :param allowed_columns_map: dict:
    :param extensions: dict:
    :param repository: Repository:

    &#34;&#34;&#34;
    table_slug = table[&#34;slug&#34;]
    table_name = table[&#34;name&#34;]
    model_name = table[&#34;model_name&#34;]
    id_field = table[&#34;id_field&#34;]
    form_class, form_schema_model = _get_form(model_name, allowed_columns_map, &#34;postList&#34;, extensions)

    request_schema = get_post_list_endpoint_schema(model_name, form_schema_model)
    extension = extensions[&#34;on_update_timestamp&#34;]

    class PostListEndpoint(AutomaticResource):
        &#34;&#34;&#34; &#34;&#34;&#34;

        route = f&#34;/update/{inflector.plural(table_slug)}&#34;
        endpoint = f&#34;{model_name}PostListEndpoint&#34;
        representations = request_schema
        db_table = table

        def validate_request(self, **args):
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            forms = args[&#34;form&#34;]
            if hasattr(args[&#34;data&#34;], &#34;maxItems&#34;) and len(args[&#34;data&#34;]) &gt; form_schema_model.maxItems:
                raise ValidationError(message=f&#34;Body too large, max items: {form_schema_model.maxItems}&#34;)
            if hasattr(args[&#34;data&#34;], &#34;minItems&#34;) and len(args[&#34;data&#34;]) &lt; form_schema_model.minItems:
                raise ValidationError(message=f&#34;Body too small, min items: {form_schema_model.minItems}&#34;)

            errors = {}
            ids = []
            for i, form in enumerate(forms):
                _data = form.data
                ids.append(_data[id_field])
                if not form.validate():
                    errors[i] = form.errors

            ids_check_sql = _MAGIC_QUERIES[repository.db_dialect][&#34;get_ids_not_in_table_from_list&#34;](
                {
                    &#34;values&#34;: [f&#34;:{id}&#34; for id in ids],
                    &#34;id_field&#34;: id_field,
                    &#34;table&#34;: table_name,
                    &#34;where&#34;: f&#39;WHERE {extension.config[&#34;default_field&#34;]} IS NULL&#39; if extension.enabled else &#34;&#34;,
                }
            )

            ids_check = repository.execute(ids_check_sql, {str(id): id for id in ids})
            not_found = ids_check.fetchall()
            if len(not_found) &gt; 0:
                errors = {**errors, **{str(x[0]): &#34;id not found&#34; for x in not_found}}

            if len(errors.keys()) &gt; 0:
                raise ValidationError(message=simplejson.dumps(errors))

        def request(self, **args) -&gt; ResourceResponse:
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            forms = args[&#34;form&#34;]
            form_data = []
            for form in forms:
                _form_data = form.data
                if extension.enabled:
                    _form_data = extension.set_field_data(_form_data)

                form_data.append(_form_data)
            response = ResourceResponse()
            try:
                repository.update_batch(table_name, form_data, where_field=id_field)
                response.response = form_data
            except sqlalchemy.exc.IntegrityError as e:
                if isinstance(e.orig, psycopg2.errors.UniqueViolation):
                    raise ValidationError(message=e.orig)
                if isinstance(e.orig, psycopg2.errors.ForeignKeyViolation):
                    raise ValidationError(message=e.orig)

            return response

        @swagger.doc(request_schema)
        def post(self):
            &#34;&#34;&#34; &#34;&#34;&#34;
            data = request.json
            form = [form_class(data=item) for item in data]
            return self.process_request(form=form, data=data)

    PostListEndpoint.__name__ = PostListEndpoint.endpoint

    return PostListEndpoint</code></pre>
</details>
</dd>
<dt id="chillapi.endpoints.tables.create_post_single_endpoint_class"><code class="name flex">
<span>def <span class="ident">create_post_single_endpoint_class</span></span>(<span>table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: <a title="chillapi.abc.Repository" href="../abc.html#chillapi.abc.Repository">Repository</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>:param table: dict:
:param allowed_columns: List:
:param allowed_columns_map: dict:
:param extensions: dict:
:param repository: Repository:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_post_single_endpoint_class(table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: Repository):
    &#34;&#34;&#34;

    :param table: dict:
    :param allowed_columns: List:
    :param allowed_columns_map: dict:
    :param extensions: dict:
    :param repository: Repository:

    &#34;&#34;&#34;
    table_slug = table[&#34;slug&#34;]
    table_name = table[&#34;name&#34;]
    model_name = table[&#34;model_name&#34;]
    id_field = table[&#34;id_field&#34;]

    response_schema = get_response_swagger_schema(allowed_columns_map, f&#34;{model_name}PostSingleEndpoint&#34;)
    update_extension = extensions[&#34;on_update_timestamp&#34;]
    soft_delete_extension = extensions[&#34;soft_delete&#34;]

    form_class, form_schema_model = _get_form(table[&#34;model_name&#34;], allowed_columns_map, &#34;post&#34;, extensions)

    id_field_where_type = _column_type_to_swagger_type_url(table[&#34;columns&#34;][id_field][&#34;type&#34;])
    request_schema = get_post_single_endpoint_schema(model_name, form_schema_model, response_schema, id_field_where_type)

    class PostSingleEndpoint(AutomaticResource):
        &#34;&#34;&#34; &#34;&#34;&#34;

        route = f&#34;/update/{table_slug}/&lt;{id_field_where_type}id&gt;&#34;
        endpoint = f&#34;{model_name}PostSingleEndpoint&#34;
        representations = request_schema
        db_table = table

        def request(self, **args) -&gt; ResourceResponse:
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            form = args[&#34;form&#34;]
            form_data = form.data
            oid = args[&#34;id&#34;]
            response = ResourceResponse()

            try:
                if update_extension.enabled:
                    form_data = update_extension.set_field_data(form_data)

                _data = {**form_data, **{id_field: oid}}
                repository.update_record(table_name, id_field, oid, _data)

                if update_extension.enabled:
                    form_data = update_extension.unset_field_data(_data)
                response.response = _data

            except sqlalchemy.exc.IntegrityError as e:
                if isinstance(e.orig, psycopg2.errors.UniqueViolation):
                    raise RequestInvalidFieldSchemaError(message=e.orig)
                if isinstance(e.orig, psycopg2.errors.ForeignKeyViolation):
                    raise RequestInvalidFieldSchemaError(message=e.orig)

            response.audit = AuditLog(
                f&#34;Update {table_name} record&#34;,
                action=&#34;UPDATE&#34;,
                current_status=response.response,
                prev_status=args[&#34;validation_output&#34;],
                change_parameters={**{&#34;entity&#34;: model_name, f&#34;{id_field}&#34;: oid}, **form_data},
            )

            return response

        def validate_request(self, **args):
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            form = args[&#34;form&#34;]
            id = args[&#34;id&#34;]
            try:
                logger.debug(&#34;Check entity exists&#34;, extra=args)

                query = {f&#34;{id_field}&#34;: {&#34;op&#34;: &#34;=&#34;, &#34;value&#34;: id}}
                query_values = {f&#34;{id_field}&#34;: id}

                if soft_delete_extension.enabled:
                    query, query_values = soft_delete_extension.add_query_filter(query, query_values)

                record = repository.fetch_by(table_name, [&#34;*&#34;], query, query_values)

                if not form.validate():
                    raise RequestInvalidFieldSchemaError(simplejson.dumps(form.errors))

                return record.one()._asdict()
            except sqlalchemy.exc.NoResultFound:
                raise NotFoundException(description=f&#34;{model_name} with id: {id} not found&#34;)
            except JsonSchemaValidationError:
                raise RequestSchemaError()

        @swagger.doc(request_schema)
        def post(self, id):
            &#34;&#34;&#34;

            :param id:

            &#34;&#34;&#34;
            data = request.json
            form = form_class(data=data)
            return self.process_request(form=form, data=data, id=id)

    PostSingleEndpoint.__name__ = PostSingleEndpoint.endpoint

    return PostSingleEndpoint</code></pre>
</details>
</dd>
<dt id="chillapi.endpoints.tables.create_put_list_endpoint_class"><code class="name flex">
<span>def <span class="ident">create_put_list_endpoint_class</span></span>(<span>table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: <a title="chillapi.abc.Repository" href="../abc.html#chillapi.abc.Repository">Repository</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>:param # noqa C901table: dict:
:param allowed_columns: List:
:param allowed_columns_map: dict:
:param extensions: dict:
:param repository: Repository:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_put_list_endpoint_class(  # noqa C901
    table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: Repository
):
    &#34;&#34;&#34;

    :param # noqa C901table: dict:
    :param allowed_columns: List:
    :param allowed_columns_map: dict:
    :param extensions: dict:
    :param repository: Repository:

    &#34;&#34;&#34;
    table_slug = table[&#34;slug&#34;]
    table_name = table[&#34;name&#34;]
    model_name = table[&#34;model_name&#34;]
    id_field = table[&#34;id_field&#34;]

    create_extension = extensions[&#34;on_create_timestamp&#34;]

    form_class, form_schema_model = _get_form(table[&#34;model_name&#34;], allowed_columns_map, &#34;putList&#34;, extensions)

    request_schema = get_put_list_endpoint_schema(model_name, form_schema_model)

    columns = allowed_columns
    if create_extension.enabled:
        columns += [create_extension.config[&#34;default_field&#34;]]

    class PutListEndpoint(AutomaticResource):
        &#34;&#34;&#34; &#34;&#34;&#34;

        route = f&#34;/create/{inflector.plural(table_slug)}&#34;
        endpoint = f&#34;{model_name}PutListEndpoint&#34;
        representations = request_schema
        db_table = table

        def validate_request(self, **args):
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            if hasattr(form_schema_model, &#34;maxItems&#34;) and len(args[&#34;data&#34;]) &gt; form_schema_model.maxItems:
                raise ValidationError(message=f&#34;Body too large, max items: {form_schema_model.maxItems}&#34;)
            if hasattr(form_schema_model, &#34;minItems&#34;) and len(args[&#34;data&#34;]) &lt; form_schema_model.minItems:
                raise ValidationError(message=f&#34;Body too small, min items: {form_schema_model.minItems}&#34;)
            forms = args[&#34;form&#34;]
            errors = {}
            for i, form in enumerate(forms):
                if not form.validate():
                    errors[i] = form.errors

            if len(errors.keys()) &gt; 0:
                raise ValidationError(message=simplejson.dumps(errors))

        def request(self, **args) -&gt; ResourceResponse:
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            forms = args[&#34;form&#34;]
            form_data = []
            for form in forms:
                _form_data = form.data
                if create_extension.enabled:
                    _form_data = create_extension.set_field_data(_form_data)
                form_data.append(_form_data)
            # form_data = [form.data for form in forms]
            response = ResourceResponse()
            response.response = {&#34;message&#34;: &#34;error&#34;, &#34;details&#34;: []}

            try:

                result = repository.insert_batch(table_name, columns, form_data, returning_field=id_field)
                response.response[&#34;message&#34;] = f&#34;Affected rows: {result}&#34;
                response.response[&#34;code&#34;] = 200
                response.http_code = 200
            except sqlalchemy.exc.IntegrityError as e:
                if isinstance(e.orig, psycopg2.errors.UniqueViolation):
                    raise ValidationError(message=e.orig)
                if isinstance(e.orig, psycopg2.errors.ForeignKeyViolation):
                    raise ValidationError(message=e.orig)

            return response

        @swagger.doc(request_schema)
        def put(self):
            &#34;&#34;&#34; &#34;&#34;&#34;
            data = request.json
            form = [form_class(data=item) for item in data]
            return self.process_request(form=form, data=data)

    PutListEndpoint.__name__ = PutListEndpoint.endpoint

    return PutListEndpoint</code></pre>
</details>
</dd>
<dt id="chillapi.endpoints.tables.create_put_single_endpoint_class"><code class="name flex">
<span>def <span class="ident">create_put_single_endpoint_class</span></span>(<span>table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: <a title="chillapi.abc.Repository" href="../abc.html#chillapi.abc.Repository">Repository</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>:param table: dict:
:param allowed_columns: List:
:param allowed_columns_map: dict:
:param extensions: dict:
:param repository: Repository:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_put_single_endpoint_class(table: dict, allowed_columns: List, allowed_columns_map: dict, extensions: dict, repository: Repository):
    &#34;&#34;&#34;

    :param table: dict:
    :param allowed_columns: List:
    :param allowed_columns_map: dict:
    :param extensions: dict:
    :param repository: Repository:

    &#34;&#34;&#34;
    table_slug = table[&#34;slug&#34;]
    table_name = table[&#34;name&#34;]
    model_name = table[&#34;model_name&#34;]
    id_field = table[&#34;id_field&#34;]
    response_schema = get_response_swagger_schema(allowed_columns_map, f&#34;{model_name}PutSingleEndpoint&#34;)
    extension = extensions[&#34;on_create_timestamp&#34;]
    extension_enabled = extension.enabled
    form_class, form_schema_model = _get_form(table[&#34;model_name&#34;], allowed_columns_map, &#34;put&#34;, extensions)
    request_schema = get_put_single_endpoint_schema(model_name, form_schema_model, response_schema)

    class PutSingleEndpoint(AutomaticResource):
        &#34;&#34;&#34; &#34;&#34;&#34;

        route = f&#34;/create/{table_slug}&#34;
        endpoint = f&#34;{model_name}PutSingleEndpoint&#34;
        representations = request_schema
        db_table = table

        def validate_request(self, **args):
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            form = args[&#34;form&#34;]
            if not form.validate():
                raise RequestInvalidFieldSchemaError(simplejson.dumps(form.errors))

        def request(self, **args) -&gt; ResourceResponse:
            &#34;&#34;&#34;

            :param **args:

            &#34;&#34;&#34;
            form = args[&#34;form&#34;]
            form_data = form.data
            response = ResourceResponse()
            try:

                params = form_data
                columns = allowed_columns

                if extension_enabled:
                    columns = extension.set_columns(columns)
                if extension_enabled:
                    params = extension.set_field_data(params)

                result = repository.insert_record(table_name, columns, params, returning_field=id_field)
                form_data[id_field] = result

                if extension_enabled:
                    params = extension.unset_field_data(params)

                response.response = form_data

                response.audit = AuditLog(
                    f&#34;Create {table_name} record&#34;,
                    action=&#34;CREATE&#34;,
                    current_status=response.response,
                    change_parameters={**{&#34;entity&#34;: model_name}, **params},
                )

            except sqlalchemy.exc.IntegrityError as e:
                if isinstance(e.orig, psycopg2.errors.UniqueViolation):
                    raise ValidationError(message=e.orig)
                if isinstance(e.orig, psycopg2.errors.ForeignKeyViolation):
                    raise ValidationError(message=e.orig)

            return response

        @swagger.doc(request_schema)
        def put(self):
            &#34;&#34;&#34; &#34;&#34;&#34;
            data = request.json
            try:
                form = form_class(data=data)
            except ValueError:
                raise RequestSchemaError()
            return self.process_request(form=form, data=data)

    PutSingleEndpoint.__name__ = PutSingleEndpoint.endpoint

    return PutSingleEndpoint</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="chillapi.endpoints" href="index.html">chillapi.endpoints</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="chillapi.endpoints.tables.create_delete_list_endpoint_class" href="#chillapi.endpoints.tables.create_delete_list_endpoint_class">create_delete_list_endpoint_class</a></code></li>
<li><code><a title="chillapi.endpoints.tables.create_delete_single_endpoint_class" href="#chillapi.endpoints.tables.create_delete_single_endpoint_class">create_delete_single_endpoint_class</a></code></li>
<li><code><a title="chillapi.endpoints.tables.create_get_list_endpoint_class" href="#chillapi.endpoints.tables.create_get_list_endpoint_class">create_get_list_endpoint_class</a></code></li>
<li><code><a title="chillapi.endpoints.tables.create_get_single_endpoint_class" href="#chillapi.endpoints.tables.create_get_single_endpoint_class">create_get_single_endpoint_class</a></code></li>
<li><code><a title="chillapi.endpoints.tables.create_post_list_endpoint_class" href="#chillapi.endpoints.tables.create_post_list_endpoint_class">create_post_list_endpoint_class</a></code></li>
<li><code><a title="chillapi.endpoints.tables.create_post_single_endpoint_class" href="#chillapi.endpoints.tables.create_post_single_endpoint_class">create_post_single_endpoint_class</a></code></li>
<li><code><a title="chillapi.endpoints.tables.create_put_list_endpoint_class" href="#chillapi.endpoints.tables.create_put_list_endpoint_class">create_put_list_endpoint_class</a></code></li>
<li><code><a title="chillapi.endpoints.tables.create_put_single_endpoint_class" href="#chillapi.endpoints.tables.create_put_single_endpoint_class">create_put_single_endpoint_class</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>
